{"uid":"fd2572c51a618df","name":"Validate Council Output [NorthKestevenDistrictCouncil]","fullName":"features/validate_council_outputs.feature:Validate Council Output","historyId":"c9c754b0aeaa9653b56f57afebc35c99","time":{"start":1677700570833,"stop":1677700571815,"duration":982},"status":"failed","statusMessage":"TypeError: object of type 'Response' has no len()","statusTrace":"fixturefunc = <function scrape_step at 0x7fc57b826280>\nrequest = <FixtureRequest for <Function test_scenario_outline[NorthKestevenDistrictCouncil]>>\nkwargs = {'context': <test_validate_council.context.<locals>.Context object at 0x7fc5719f9eb0>, 'council': 'NorthKestevenDistrictCouncil'}\n\n    def call_fixture_func(\n        fixturefunc: \"_FixtureFunc[FixtureValue]\", request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if is_generator(fixturefunc):\n            fixturefunc = cast(\n                Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n            )\n            generator = fixturefunc(**kwargs)\n            try:\n                fixture_result = next(generator)\n            except StopIteration:\n                raise ValueError(f\"{request.fixturename} did not yield a value\") from None\n            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n            request.addfinalizer(finalizer)\n        else:\n            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)\n>           fixture_result = fixturefunc(**kwargs)\n\n../../../.cache/pypoetry/virtualenvs/uk-bin-collection-EwS6Gn8s-py3.8/lib/python3.8/site-packages/_pytest/fixtures.py:908: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nuk_bin_collection/tests/step_defs/test_validate_council.py:59: in scrape_step\n    raise(err)\nuk_bin_collection/tests/step_defs/test_validate_council.py:55: in scrape_step\n    context.parse_result = collect_data.main(args)\nuk_bin_collection/uk_bin_collection/collect_data.py:67: in main\n    return client_code(\nuk_bin_collection/uk_bin_collection/collect_data.py:23: in client_code\n    return get_bin_data_class.template_method(address_url, **kwargs)\nuk_bin_collection/uk_bin_collection/get_bin_data.py:57: in template_method\n    bin_data_dict = self.parse_data(\nuk_bin_collection/uk_bin_collection/councils/NorthKestevenDistrictCouncil.py:16: in parse_data\n    soup = BeautifulSoup(page, features=\"html.parser\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'<class 'bs4.BeautifulSoup'>' object has no attribute 'contents'\") raised in repr()] BeautifulSoup object at 0x7fc5719c2910>\nmarkup = <Response [500]>, features = ['html.parser']\nbuilder = <bs4.builder._htmlparser.HTMLParserTreeBuilder object at 0x7fc5719c2520>\nparse_only = None, from_encoding = None, exclude_encodings = None\nelement_classes = None, kwargs = {}\ndeprecated_argument = <function BeautifulSoup.__init__.<locals>.deprecated_argument at 0x7fc571ac79d0>\noriginal_builder = None, original_features = 'html.parser'\nbuilder_class = <class 'bs4.builder._htmlparser.HTMLParserTreeBuilder'>\n\n    def __init__(self, markup=\"\", features=None, builder=None,\n                 parse_only=None, from_encoding=None, exclude_encodings=None,\n                 element_classes=None, **kwargs):\n        \"\"\"Constructor.\n    \n        :param markup: A string or a file-like object representing\n         markup to be parsed.\n    \n        :param features: Desirable features of the parser to be\n         used. This may be the name of a specific parser (\"lxml\",\n         \"lxml-xml\", \"html.parser\", or \"html5lib\") or it may be the\n         type of markup to be used (\"html\", \"html5\", \"xml\"). It's\n         recommended that you name a specific parser, so that\n         Beautiful Soup gives you the same results across platforms\n         and virtual environments.\n    \n        :param builder: A TreeBuilder subclass to instantiate (or\n         instance to use) instead of looking one up based on\n         `features`. You only need to use this if you've implemented a\n         custom TreeBuilder.\n    \n        :param parse_only: A SoupStrainer. Only parts of the document\n         matching the SoupStrainer will be considered. This is useful\n         when parsing part of a document that would otherwise be too\n         large to fit into memory.\n    \n        :param from_encoding: A string indicating the encoding of the\n         document to be parsed. Pass this in if Beautiful Soup is\n         guessing wrongly about the document's encoding.\n    \n        :param exclude_encodings: A list of strings indicating\n         encodings known to be wrong. Pass this in if you don't know\n         the document's encoding but you know Beautiful Soup's guess is\n         wrong.\n    \n        :param element_classes: A dictionary mapping BeautifulSoup\n         classes like Tag and NavigableString, to other classes you'd\n         like to be instantiated instead as the parse tree is\n         built. This is useful for subclassing Tag or NavigableString\n         to modify default behavior.\n    \n        :param kwargs: For backwards compatibility purposes, the\n         constructor accepts certain keyword arguments used in\n         Beautiful Soup 3. None of these arguments do anything in\n         Beautiful Soup 4; they will result in a warning and then be\n         ignored.\n    \n         Apart from this, any keyword arguments passed into the\n         BeautifulSoup constructor are propagated to the TreeBuilder\n         constructor. This makes it possible to configure a\n         TreeBuilder by passing in arguments, not just by saying which\n         one to use.\n        \"\"\"\n        if 'convertEntities' in kwargs:\n            del kwargs['convertEntities']\n            warnings.warn(\n                \"BS4 does not respect the convertEntities argument to the \"\n                \"BeautifulSoup constructor. Entities are always converted \"\n                \"to Unicode characters.\")\n    \n        if 'markupMassage' in kwargs:\n            del kwargs['markupMassage']\n            warnings.warn(\n                \"BS4 does not respect the markupMassage argument to the \"\n                \"BeautifulSoup constructor. The tree builder is responsible \"\n                \"for any necessary markup massage.\")\n    \n        if 'smartQuotesTo' in kwargs:\n            del kwargs['smartQuotesTo']\n            warnings.warn(\n                \"BS4 does not respect the smartQuotesTo argument to the \"\n                \"BeautifulSoup constructor. Smart quotes are always converted \"\n                \"to Unicode characters.\")\n    \n        if 'selfClosingTags' in kwargs:\n            del kwargs['selfClosingTags']\n            warnings.warn(\n                \"BS4 does not respect the selfClosingTags argument to the \"\n                \"BeautifulSoup constructor. The tree builder is responsible \"\n                \"for understanding self-closing tags.\")\n    \n        if 'isHTML' in kwargs:\n            del kwargs['isHTML']\n            warnings.warn(\n                \"BS4 does not respect the isHTML argument to the \"\n                \"BeautifulSoup constructor. Suggest you use \"\n                \"features='lxml' for HTML and features='lxml-xml' for \"\n                \"XML.\")\n    \n        def deprecated_argument(old_name, new_name):\n            if old_name in kwargs:\n                warnings.warn(\n                    'The \"%s\" argument to the BeautifulSoup constructor '\n                    'has been renamed to \"%s.\"' % (old_name, new_name),\n                    DeprecationWarning, stacklevel=3\n                )\n                return kwargs.pop(old_name)\n            return None\n    \n        parse_only = parse_only or deprecated_argument(\n            \"parseOnlyThese\", \"parse_only\")\n    \n        from_encoding = from_encoding or deprecated_argument(\n            \"fromEncoding\", \"from_encoding\")\n    \n        if from_encoding and isinstance(markup, str):\n            warnings.warn(\"You provided Unicode markup but also provided a value for from_encoding. Your from_encoding will be ignored.\")\n            from_encoding = None\n    \n        self.element_classes = element_classes or dict()\n    \n        # We need this information to track whether or not the builder\n        # was specified well enough that we can omit the 'you need to\n        # specify a parser' warning.\n        original_builder = builder\n        original_features = features\n    \n        if isinstance(builder, type):\n            # A builder class was passed in; it needs to be instantiated.\n            builder_class = builder\n            builder = None\n        elif builder is None:\n            if isinstance(features, str):\n                features = [features]\n            if features is None or len(features) == 0:\n                features = self.DEFAULT_BUILDER_FEATURES\n            builder_class = builder_registry.lookup(*features)\n            if builder_class is None:\n                raise FeatureNotFound(\n                    \"Couldn't find a tree builder with the features you \"\n                    \"requested: %s. Do you need to install a parser library?\"\n                    % \",\".join(features))\n    \n        # At this point either we have a TreeBuilder instance in\n        # builder, or we have a builder_class that we can instantiate\n        # with the remaining **kwargs.\n        if builder is None:\n            builder = builder_class(**kwargs)\n            if not original_builder and not (\n                    original_features == builder.NAME or\n                    original_features in builder.ALTERNATE_NAMES\n            ) and markup:\n                # The user did not tell us which TreeBuilder to use,\n                # and we had to guess. Issue a warning.\n                if builder.is_xml:\n                    markup_type = \"XML\"\n                else:\n                    markup_type = \"HTML\"\n    \n                # This code adapted from warnings.py so that we get the same line\n                # of code as our warnings.warn() call gets, even if the answer is wrong\n                # (as it may be in a multithreading situation).\n                caller = None\n                try:\n                    caller = sys._getframe(1)\n                except ValueError:\n                    pass\n                if caller:\n                    globals = caller.f_globals\n                    line_number = caller.f_lineno\n                else:\n                    globals = sys.__dict__\n                    line_number= 1\n                filename = globals.get('__file__')\n                if filename:\n                    fnl = filename.lower()\n                    if fnl.endswith((\".pyc\", \".pyo\")):\n                        filename = filename[:-1]\n                if filename:\n                    # If there is no filename at all, the user is most likely in a REPL,\n                    # and the warning is not necessary.\n                    values = dict(\n                        filename=filename,\n                        line_number=line_number,\n                        parser=builder.NAME,\n                        markup_type=markup_type\n                    )\n                    warnings.warn(\n                        self.NO_PARSER_SPECIFIED_WARNING % values,\n                        GuessedAtParserWarning, stacklevel=2\n                    )\n        else:\n            if kwargs:\n                warnings.warn(\"Keyword arguments to the BeautifulSoup constructor will be ignored. These would normally be passed into the TreeBuilder constructor, but a TreeBuilder instance was passed in as `builder`.\")\n    \n        self.builder = builder\n        self.is_xml = builder.is_xml\n        self.known_xml = self.is_xml\n        self._namespaces = dict()\n        self.parse_only = parse_only\n    \n        if hasattr(markup, 'read'):        # It's a file-type object.\n            markup = markup.read()\n>       elif len(markup) <= 256 and (\n                (isinstance(markup, bytes) and not b'<' in markup)\n                or (isinstance(markup, str) and not '<' in markup)\n        ):\nE       TypeError: object of type 'Response' has no len()\n\n../../../.cache/pypoetry/virtualenvs/uk-bin-collection-EwS6Gn8s-py3.8/lib/python3.8/site-packages/bs4/__init__.py:313: TypeError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"status":"failed","statusMessage":"TypeError: object of type 'Response' has no len()","statusTrace":"fixturefunc = <function scrape_step at 0x7fc57b826280>\nrequest = <FixtureRequest for <Function test_scenario_outline[NorthKestevenDistrictCouncil]>>\nkwargs = {'context': <test_validate_council.context.<locals>.Context object at 0x7fc5719f9eb0>, 'council': 'NorthKestevenDistrictCouncil'}\n\n    def call_fixture_func(\n        fixturefunc: \"_FixtureFunc[FixtureValue]\", request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if is_generator(fixturefunc):\n            fixturefunc = cast(\n                Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n            )\n            generator = fixturefunc(**kwargs)\n            try:\n                fixture_result = next(generator)\n            except StopIteration:\n                raise ValueError(f\"{request.fixturename} did not yield a value\") from None\n            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n            request.addfinalizer(finalizer)\n        else:\n            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)\n>           fixture_result = fixturefunc(**kwargs)\n\n../../../.cache/pypoetry/virtualenvs/uk-bin-collection-EwS6Gn8s-py3.8/lib/python3.8/site-packages/_pytest/fixtures.py:908: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nuk_bin_collection/tests/step_defs/test_validate_council.py:59: in scrape_step\n    raise(err)\nuk_bin_collection/tests/step_defs/test_validate_council.py:55: in scrape_step\n    context.parse_result = collect_data.main(args)\nuk_bin_collection/uk_bin_collection/collect_data.py:67: in main\n    return client_code(\nuk_bin_collection/uk_bin_collection/collect_data.py:23: in client_code\n    return get_bin_data_class.template_method(address_url, **kwargs)\nuk_bin_collection/uk_bin_collection/get_bin_data.py:57: in template_method\n    bin_data_dict = self.parse_data(\nuk_bin_collection/uk_bin_collection/councils/NorthKestevenDistrictCouncil.py:16: in parse_data\n    soup = BeautifulSoup(page, features=\"html.parser\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'<class 'bs4.BeautifulSoup'>' object has no attribute 'contents'\") raised in repr()] BeautifulSoup object at 0x7fc5719c2910>\nmarkup = <Response [500]>, features = ['html.parser']\nbuilder = <bs4.builder._htmlparser.HTMLParserTreeBuilder object at 0x7fc5719c2520>\nparse_only = None, from_encoding = None, exclude_encodings = None\nelement_classes = None, kwargs = {}\ndeprecated_argument = <function BeautifulSoup.__init__.<locals>.deprecated_argument at 0x7fc571ac79d0>\noriginal_builder = None, original_features = 'html.parser'\nbuilder_class = <class 'bs4.builder._htmlparser.HTMLParserTreeBuilder'>\n\n    def __init__(self, markup=\"\", features=None, builder=None,\n                 parse_only=None, from_encoding=None, exclude_encodings=None,\n                 element_classes=None, **kwargs):\n        \"\"\"Constructor.\n    \n        :param markup: A string or a file-like object representing\n         markup to be parsed.\n    \n        :param features: Desirable features of the parser to be\n         used. This may be the name of a specific parser (\"lxml\",\n         \"lxml-xml\", \"html.parser\", or \"html5lib\") or it may be the\n         type of markup to be used (\"html\", \"html5\", \"xml\"). It's\n         recommended that you name a specific parser, so that\n         Beautiful Soup gives you the same results across platforms\n         and virtual environments.\n    \n        :param builder: A TreeBuilder subclass to instantiate (or\n         instance to use) instead of looking one up based on\n         `features`. You only need to use this if you've implemented a\n         custom TreeBuilder.\n    \n        :param parse_only: A SoupStrainer. Only parts of the document\n         matching the SoupStrainer will be considered. This is useful\n         when parsing part of a document that would otherwise be too\n         large to fit into memory.\n    \n        :param from_encoding: A string indicating the encoding of the\n         document to be parsed. Pass this in if Beautiful Soup is\n         guessing wrongly about the document's encoding.\n    \n        :param exclude_encodings: A list of strings indicating\n         encodings known to be wrong. Pass this in if you don't know\n         the document's encoding but you know Beautiful Soup's guess is\n         wrong.\n    \n        :param element_classes: A dictionary mapping BeautifulSoup\n         classes like Tag and NavigableString, to other classes you'd\n         like to be instantiated instead as the parse tree is\n         built. This is useful for subclassing Tag or NavigableString\n         to modify default behavior.\n    \n        :param kwargs: For backwards compatibility purposes, the\n         constructor accepts certain keyword arguments used in\n         Beautiful Soup 3. None of these arguments do anything in\n         Beautiful Soup 4; they will result in a warning and then be\n         ignored.\n    \n         Apart from this, any keyword arguments passed into the\n         BeautifulSoup constructor are propagated to the TreeBuilder\n         constructor. This makes it possible to configure a\n         TreeBuilder by passing in arguments, not just by saying which\n         one to use.\n        \"\"\"\n        if 'convertEntities' in kwargs:\n            del kwargs['convertEntities']\n            warnings.warn(\n                \"BS4 does not respect the convertEntities argument to the \"\n                \"BeautifulSoup constructor. Entities are always converted \"\n                \"to Unicode characters.\")\n    \n        if 'markupMassage' in kwargs:\n            del kwargs['markupMassage']\n            warnings.warn(\n                \"BS4 does not respect the markupMassage argument to the \"\n                \"BeautifulSoup constructor. The tree builder is responsible \"\n                \"for any necessary markup massage.\")\n    \n        if 'smartQuotesTo' in kwargs:\n            del kwargs['smartQuotesTo']\n            warnings.warn(\n                \"BS4 does not respect the smartQuotesTo argument to the \"\n                \"BeautifulSoup constructor. Smart quotes are always converted \"\n                \"to Unicode characters.\")\n    \n        if 'selfClosingTags' in kwargs:\n            del kwargs['selfClosingTags']\n            warnings.warn(\n                \"BS4 does not respect the selfClosingTags argument to the \"\n                \"BeautifulSoup constructor. The tree builder is responsible \"\n                \"for understanding self-closing tags.\")\n    \n        if 'isHTML' in kwargs:\n            del kwargs['isHTML']\n            warnings.warn(\n                \"BS4 does not respect the isHTML argument to the \"\n                \"BeautifulSoup constructor. Suggest you use \"\n                \"features='lxml' for HTML and features='lxml-xml' for \"\n                \"XML.\")\n    \n        def deprecated_argument(old_name, new_name):\n            if old_name in kwargs:\n                warnings.warn(\n                    'The \"%s\" argument to the BeautifulSoup constructor '\n                    'has been renamed to \"%s.\"' % (old_name, new_name),\n                    DeprecationWarning, stacklevel=3\n                )\n                return kwargs.pop(old_name)\n            return None\n    \n        parse_only = parse_only or deprecated_argument(\n            \"parseOnlyThese\", \"parse_only\")\n    \n        from_encoding = from_encoding or deprecated_argument(\n            \"fromEncoding\", \"from_encoding\")\n    \n        if from_encoding and isinstance(markup, str):\n            warnings.warn(\"You provided Unicode markup but also provided a value for from_encoding. Your from_encoding will be ignored.\")\n            from_encoding = None\n    \n        self.element_classes = element_classes or dict()\n    \n        # We need this information to track whether or not the builder\n        # was specified well enough that we can omit the 'you need to\n        # specify a parser' warning.\n        original_builder = builder\n        original_features = features\n    \n        if isinstance(builder, type):\n            # A builder class was passed in; it needs to be instantiated.\n            builder_class = builder\n            builder = None\n        elif builder is None:\n            if isinstance(features, str):\n                features = [features]\n            if features is None or len(features) == 0:\n                features = self.DEFAULT_BUILDER_FEATURES\n            builder_class = builder_registry.lookup(*features)\n            if builder_class is None:\n                raise FeatureNotFound(\n                    \"Couldn't find a tree builder with the features you \"\n                    \"requested: %s. Do you need to install a parser library?\"\n                    % \",\".join(features))\n    \n        # At this point either we have a TreeBuilder instance in\n        # builder, or we have a builder_class that we can instantiate\n        # with the remaining **kwargs.\n        if builder is None:\n            builder = builder_class(**kwargs)\n            if not original_builder and not (\n                    original_features == builder.NAME or\n                    original_features in builder.ALTERNATE_NAMES\n            ) and markup:\n                # The user did not tell us which TreeBuilder to use,\n                # and we had to guess. Issue a warning.\n                if builder.is_xml:\n                    markup_type = \"XML\"\n                else:\n                    markup_type = \"HTML\"\n    \n                # This code adapted from warnings.py so that we get the same line\n                # of code as our warnings.warn() call gets, even if the answer is wrong\n                # (as it may be in a multithreading situation).\n                caller = None\n                try:\n                    caller = sys._getframe(1)\n                except ValueError:\n                    pass\n                if caller:\n                    globals = caller.f_globals\n                    line_number = caller.f_lineno\n                else:\n                    globals = sys.__dict__\n                    line_number= 1\n                filename = globals.get('__file__')\n                if filename:\n                    fnl = filename.lower()\n                    if fnl.endswith((\".pyc\", \".pyo\")):\n                        filename = filename[:-1]\n                if filename:\n                    # If there is no filename at all, the user is most likely in a REPL,\n                    # and the warning is not necessary.\n                    values = dict(\n                        filename=filename,\n                        line_number=line_number,\n                        parser=builder.NAME,\n                        markup_type=markup_type\n                    )\n                    warnings.warn(\n                        self.NO_PARSER_SPECIFIED_WARNING % values,\n                        GuessedAtParserWarning, stacklevel=2\n                    )\n        else:\n            if kwargs:\n                warnings.warn(\"Keyword arguments to the BeautifulSoup constructor will be ignored. These would normally be passed into the TreeBuilder constructor, but a TreeBuilder instance was passed in as `builder`.\")\n    \n        self.builder = builder\n        self.is_xml = builder.is_xml\n        self.known_xml = self.is_xml\n        self._namespaces = dict()\n        self.parse_only = parse_only\n    \n        if hasattr(markup, 'read'):        # It's a file-type object.\n            markup = markup.read()\n>       elif len(markup) <= 256 and (\n                (isinstance(markup, bytes) and not b'<' in markup)\n                or (isinstance(markup, str) and not '<' in markup)\n        ):\nE       TypeError: object of type 'Response' has no len()\n\n../../../.cache/pypoetry/virtualenvs/uk-bin-collection-EwS6Gn8s-py3.8/lib/python3.8/site-packages/bs4/__init__.py:313: TypeError","steps":[{"name":"Given the council: NorthKestevenDistrictCouncil","time":{"start":1677700570833,"stop":1677700570834,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"When we scrape the data from NorthKestevenDistrictCouncil","time":{"start":1677700570834,"stop":1677700571815,"duration":981},"status":"failed","statusMessage":"object of type 'Response' has no len()","statusTrace":"TypeError: object of type 'Response' has no len()\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true}],"attachments":[],"parameters":[],"stepsCount":2,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true},"afterStages":[],"labels":[{"name":"host","value":"fv-az551-205"},{"name":"thread","value":"2620-MainThread"},{"name":"framework","value":"pytest-bdd"},{"name":"language","value":"cpython3"},{"name":"feature","value":"Test each council output matches expected results in /outputs"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"fd2572c51a618df.json","parameterValues":[]}